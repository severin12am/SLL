<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - animation - keyframes</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <link type="text/css" rel="stylesheet" href="main.css">
        <!-- Remove Supabase CDN -->
        <style>
            body {
                background-color: #bfe3dd;
                color: #000;
                margin: 0;
                overflow: hidden;
            }

            a {
                color: #2983ff;
            }

            /* UI Styles */
            #ui-overlay {
                position: absolute;
                bottom: 10px;
                left: 50%;
                transform: translateX(-50%);
                background: transparent;
                padding: 10px;
                border-radius: 5px;
                font-family: Arial, sans-serif;
                max-width: 1800px; /* Doubled from 900px */
                text-align: center;
                width: 100%;
            }

            #dialogue-boxes {
                position: fixed;
                bottom: 100px;
                left: 50%;
                transform: translateX(-50%);
                width: 90%;
                max-width: 600px;
                z-index: 1001; /* Higher than mobile controls */
                pointer-events: auto; /* Allow touch events */
            }

            .dialogue-container {
                position: absolute;
                margin-bottom: 5px;
                display: flex;
                align-items: center;
                gap: 10px;
                left: 0;
                right: 0;
                bottom: 0;
                transform: translateY(0);
                transition: transform 0.3s ease-out;
            }

            .dialogue-box {
                margin: 5px 0;
                padding: 10x 15px;
                background: rgba(255, 248, 220, 0.95);
                border-radius: 5px;
                transition: transform 0.5s ease;
                flex-grow: 1;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                line-height: 1.2;
                pointer-events: auto; /* Ensure dialogue boxes receive touch events */
            }

            .dialogue-box:hover {
                background: rgba(255, 248, 220, 0.98);
            }

            .dialogue-box.vendor {
                background: rgba(230, 240, 255, 0.95);
            }

            .replay-button {
                flex-shrink: 0;
                height: 30px;
                width: 30px;
                border-radius: 50%;
                background: rgba(255, 255, 255, 0.9);
                border: 2px solid #666;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: transform 0.2s ease, background-color 0.2s ease;
                margin-right: 10px;
                position: relative;
                pointer-events: auto; /* Ensure replay buttons receive touch events */
            }

            .replay-button:hover {
                transform: scale(1.1);
                background: rgba(255, 255, 255, 1);
                border-color: #0066cc;
            }

            .replay-button:active {
                transform: scale(0.95);
            }

            .replay-button::before {
                content: '';
                width: 12px;
                height: 12px;
                border: 2px solid #666;
                border-left: 0;
                border-top: 0;
                position: absolute;
                transform: rotate(135deg) translate(-2px, -2px);
            }

            .replay-button::after {
                content: '';
                width: 0;
                height: 0;
                border-style: solid;
                border-width: 4px 0 4px 6px;
                border-color: transparent transparent transparent #666;
                position: absolute;
                left: 8px;
                top: 8px;
            }

            .replay-button:hover::before {
                border-color: #0066cc;
            }

            .replay-button:hover::after {
                border-left-color: #0066cc;
            }

            .dialogue-container.position-1 { transform: translateY(0); }
.dialogue-container.position-2 { transform: translateY(-40px); } /* Reduced from -50px */
.dialogue-container.position-3 { transform: translateY(-80px); } /* Reduced from -100px */
.dialogue-container.position-4 { transform: translateY(-120px); } /* Reduced from -150px */
.dialogue-container.position-5 { transform: translateY(-160px); } /* Reduced from -200px */
.dialogue-container.position-6 { transform: translateY(-200px); } /* Reduced from -250px */
.dialogue-container.position-7 { transform: translateY(-240px); } /* Reduced from -300px */
.dialogue-container.position-8 { transform: translateY(-280px); } /* Reduced from -350px */
.dialogue-container.position-9 { transform: translateY(-320px); } /* Reduced from -400px */
.dialogue-container.position-10 { transform: translateY(-360px); } /* Reduced from -450px */

            .highlighted {
                color: #000000; /* Change from #0066cc to black */
            }

            .instruction {
                color: #666;
                font-style: italic;
            }

            /* Create a separate class for flashing instruction */
            .instruction-flash {
                animation: flash 1.5s infinite;
            }

            .translation {
                color: #2e8b57; /* Sea green */
            }

            /* UI Styles */
            #language-selection {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.85);
                padding: 30px;
                border-radius: 15px;
                z-index: 1000;
                text-align: center;
                color: white;
                min-width: 300px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            }

            #language-selection h2 {
                margin: 0 0 20px 0;
                font-size: 24px;
                color: #4CAF50;
            }

            .language-select-container {
                display: flex;
                flex-direction: column;
                gap: 15px;
                margin-bottom: 25px;
            }

            .language-select-wrapper {
                display: flex;
                flex-direction: column;
                align-items: flex-start;
                gap: 5px;
            }

            .language-select-wrapper label {
                font-size: 16px;
                color: #bfe3dd;
                margin-left: 5px;
            }

            .language-select {
                margin: 0;
                padding: 10px;
                background: #333;
                color: white;
                border: 2px solid #4CAF50;
                border-radius: 8px;
                width: 100%;
                font-size: 16px;
                transition: border-color 0.3s ease;
            }

            .language-select:hover {
                border-color: #45a049;
            }

            .language-select:focus {
                outline: none;
                border-color: #4CAF50;
                box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);
            }

            .start-button {
                margin-top: 10px;
                padding: 12px 30px;
                background: #4CAF50;
                color: white;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                font-size: 16px;
                font-weight: bold;
                transition: all 0.3s ease;
                width: 100%;
            }

            .start-button:hover {
                background: #45a049;
                transform: translateY(-2px);
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            }

            .start-button:active {
                transform: translateY(0);
                box-shadow: none;
            }

            @keyframes flash {
                0%, 100% { opacity: 1; }
                50% { opacity: 0.3; }
            }

            /* Add new rules for Arabic text */
            [lang="ar"],
            .dialogue-box:lang(ar),
            .dialogue-box .highlighted:lang(ar),
            .dialogue-box .instruction:lang(ar),
            .dialogue-box .translation:lang(ar),
            .dialogue-box .word:lang(ar) {
                font-size: 150%;
                line-height: 1.5;
            }

            .speaker-button {
                flex-shrink: 0;
                height: 30px;
                width: 30px;
                border-radius: 50%;
                background: rgba(255, 255, 255, 0.9);
                border: 2px solid #666;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: transform 0.2s ease, background-color 0.2s ease;
                margin-left: 10px;
                position: relative;
            }

            .speaker-button:hover {
                transform: scale(1.1);
                background: rgba(255, 255, 255, 1);
                border-color: #0066cc;
            }

            .speaker-button:active {
                transform: scale(0.95);
            }

            .speaker-button::before {
                content: 'üîä';
                font-size: 16px;
            }

            /* Mobile Controls */
            #mobile-controls {
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                width: 240px;
                height: 80px;
                z-index: 1000;
                display: none;
                pointer-events: auto; /* Ensure controls receive touch events */
            }

            .d-pad-button {
                position: absolute;
                background: rgba(255, 255, 255, 0.7);
                border: 1px solid rgba(0, 0, 0, 0.2);
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 18px;
                cursor: pointer;
                user-select: none;
                -webkit-user-select: none;
                box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                pointer-events: auto; /* Ensure buttons receive touch events */
            }

            .d-pad-button:active {
                background: rgba(200, 200, 200, 0.8);
                transform: translateY(1px);
                box-shadow: 0 1px 2px rgba(0,0,0,0.2);
            }

            #up-btn {
                top: 0;
                left: 60px;
                width: 120px;
                height: 35px; /* Reduced height */
                border-radius: 8px 8px 0 0;
            }

            #down-btn {
                bottom: 0;
                left: 60px;
                width: 120px;
                height: 35px; /* Reduced height */
                border-radius: 0 0 8px 8px;
            }

            #left-btn {
                left: 0;
                height: 80px; /* Full height but reduced */
                width: 50px; /* Slightly narrower */
                border-radius: 8px;
            }

            #right-btn {
                right: 0;
                height: 80px; /* Full height but reduced */
                width: 50px; /* Slightly narrower */
                border-radius: 8px;
            }

            /* Show mobile controls on touch devices and small screens */
            @media (max-width: 1024px), (hover: none) {
                #mobile-controls {
                    display: block !important;
                }
                
                #dialogue-boxes {
                    bottom: 100px;
                    max-height: calc(100vh - 120px);
                    overflow-y: auto;
                    -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
                }

                .dialogue-container {
                    margin-bottom: 8px;
                }
            }

            /* Hide mobile controls on desktop */
            @media (min-width: 1025px) and (hover: hover) {
                #mobile-controls {
                    display: none !important;
                }
            }
        </style>
        <!-- Relaxed CSP to allow inline scripts, eval, workers, and external connections -->
        <meta http-equiv="Content-Security-Policy" content="default-src 'self' https://*.supabase.co https://esm.sh data: blob: chrome-extension:; script-src 'self' 'unsafe-eval' 'unsafe-inline' https://*.supabase.co https://esm.sh chrome-extension:; connect-src 'self' data: blob: https://*.supabase.co wss://*.supabase.co https://esm.sh chrome-extension:; worker-src 'self' blob:; img-src 'self' data: blob: chrome-extension:; media-src 'self' data: blob: chrome-extension:">
    </head>

    <body>
        <div id="container"></div>

        <div id="info">
            <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - animation - keyframes<br/>
            Model: <a href="https://artstation.com/artwork/1AGwX" target="_blank" rel="noopener">Littlest Tokyo</a> by
            <a href="https://artstation.com/glenatron" target="_blank" rel="noopener">Glen Fox</a>, CC Attribution.
        </div>

        <!-- UI Overlay for Dialogue Boxes -->
        <div id="ui-overlay">
            <div id="dialogue-boxes"></div>
        </div>

        <!-- Add language selection UI -->
        <div id="language-selection">
            <h2>Select Languages</h2>
            <div class="language-select-container">
                <div class="language-select-wrapper">
                    <label for="mother-language">Your Language:</label>
                    <select id="mother-language" class="language-select">
                        <option value="en" selected>English</option>
                        <option value="es">Spanish</option>
                        <option value="ru">Russian</option>
                        <option value="ar">Arabic</option>
                    </select>
                </div>
                <div class="language-select-wrapper">
                    <label for="new-language">Language to Learn:</label>
                    <select id="new-language" class="language-select">
                        <option value="es">Spanish</option>
                        <option value="ru">Russian</option>
                        <option value="ar">Arabic</option>
                    </select>
                </div>
            </div>
            <button id="start-game" class="start-button">Start Learning</button>
        </div>

        <!-- Mobile Controls -->
        <div id="mobile-controls">
            <div class="d-pad">
                <div id="up-btn" class="d-pad-button">‚¨ÜÔ∏è</div>
                <div id="down-btn" class="d-pad-button">‚¨áÔ∏è</div>
                <div id="left-btn" class="d-pad-button">‚¨ÖÔ∏è</div>
                <div id="right-btn" class="d-pad-button">‚û°Ô∏è</div>
            </div>
        </div>

        <!-- Move script tags outside of body to avoid CSP inline script issues -->
        <script type="importmap">
            {
    "imports": {
        "three": "./build/three.module.js",
        "three/addons/": "./jsm/",
        "@supabase/supabase-js": "https://esm.sh/@supabase/supabase-js@2"
    }
}
        </script>

        <script type="module">
            import * as THREE from 'three';
            import Stats from 'three/addons/libs/stats.module.js';
            import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
            import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
            import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
            import { createClient } from '@supabase/supabase-js';

            // Initialize variables first
            let dialogueSteps = {};
            let vendorResponses = {};
            let mixer, player, vendor;
            const dialogueBoxesElement = document.getElementById('dialogue-boxes');
            let hasStartedDialogue = false;
            let hasShownVendorResponse = false;
            let lastRecognitionTime = 0;
            let dialogueBoxes = [];
            let currentStep = 0;

            // Initialize Supabase client
            const supabaseUrl = 'https://fjvltffpcafcbbpwzyml.supabase.co';
            const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZqdmx0ZmZwY2FmY2JicHd6eW1sIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDI0MjUxNTQsImV4cCI6MjA1ODAwMTE1NH0.uuhJLxTJL26r2jfD9Cb5IMKYaScDNsJeHYJue4pfWRk';
            const supabase = createClient(supabaseUrl, supabaseKey);

            // Replace hardcoded language config with dynamic data
            let languageConfig = {
                motherLanguage: 'en',
                newLanguage: 'es',
                translations: {}
            };

            // Function to fetch languages from Supabase
            async function fetchLanguages() {
                const { data: languages, error } = await supabase
                    .from('languages')
                    .select('*')
                    .eq('is_active', true);

                if (error) {
                    console.error('Error fetching languages:', error);
                    return;
                }

                // Populate language selection dropdowns
                const motherLanguageSelect = document.getElementById('mother-language');
                const newLanguageSelect = document.getElementById('new-language');
                
                motherLanguageSelect.innerHTML = '';
                newLanguageSelect.innerHTML = '';

                languages.forEach(lang => {
                    const option1 = new Option(lang.name, lang.code);
                    const option2 = new Option(lang.name, lang.code);
                    motherLanguageSelect.add(option1);
                    newLanguageSelect.add(option2);
                });
            }

            // Replace all Pop Cat loading code with this single implementation
            let popCatInstance = null;  // Single source of truth for Pop Cat instance

            function loadPopCat() {
                return new Promise((resolve, reject) => {
                    const catLoader = new GLTFLoader();
                    catLoader.load('models/pop_cat.glb', 
                        (gltf) => {
                            if (!popCatInstance) {
                                popCatInstance = gltf.scene;
                                popCatInstance.position.set(2.1, -0.9, 1.9);
                                popCatInstance.scale.set(0.013, 0.013, 0.013);
                                popCatInstance.rotation.y = Math.PI / 4;
                                popCatInstance.characterId = 5;
                                scene.add(popCatInstance);
                                characters.popCat = popCatInstance;

                                // Set up animation mixer
                                popCatMixer = new THREE.AnimationMixer(popCatInstance);
                                if (gltf.animations && gltf.animations.length > 0) {
                                    popCatAnimation = popCatMixer.clipAction(gltf.animations[0]);
                                    popCatAnimation.setLoop(THREE.LoopOnce);
                                    popCatAnimation.clampWhenFinished = true;
                                }

                                console.log("Pop Cat loaded:", popCatInstance);
                            }
                            resolve(popCatInstance);
                        },
                        undefined,
                        (error) => {
                            console.error('Error loading pop_cat model:', error);
                            reject(error);
                        }
                    );
                });
            }

            // Update the fetchCharacters function to properly initialize the vendor
            function fetchCharacters() {
                return new Promise((resolve, reject) => {
                    supabase
                        .from('characters')
                        .select('*')
                        .eq('is_active', true)
                        .then(({ data: charactersData, error }) => {
                            if (error) {
                                console.error('Error fetching characters:', error);
                                return reject(error);
                            }

                            console.log("Fetched characters data:", charactersData);

                            const loadingPromises = [];

                            // Load each character model
                            charactersData.forEach(character => {
                                // Skip Pop Cat as it's handled separately
                                if (character.name === 'Pop Cat') return;

                                const promise = new Promise((resolveLoad, rejectLoad) => {
                                    const loader = new GLTFLoader();
                                    loader.load(character.model_path, 
                                        (gltf) => {
                                            const model = gltf.scene;
                                            model.position.set(character.position_x, character.position_y, character.position_z);
                                            model.scale.set(character.scale_x, character.scale_y, character.scale_z);
                                            model.characterId = character.id; // Add character ID to the model
                                            scene.add(model);
                                            registerCollidableObject(model); // Register model for collision detection
                                            
                                            if (character.name === 'Market Vendor') {
                                                vendor = model;
                                                characters.vendor = model;
                                                console.log("Vendor loaded with ID:", character.id, vendor);
                                            }
                                            // Also store other characters if needed, e.g. based on name or ID
                                            // characters[character.name] = model; // Example
                                            
                                            resolveLoad(model); // Resolve the promise for this character
                                        },
                                        undefined,
                                        (error) => {
                                            console.error(`Error loading model ${character.name}:`, error);
                                            rejectLoad(error); // Reject the promise for this character
                                        }
                                    );
                                });
                                loadingPromises.push(promise);
                            });

                            // Wait for all character models to load
                            Promise.all(loadingPromises)
                                .then(() => {
                                    console.log("All character models loaded.");
                                    resolve(); // Resolve the main fetchCharacters promise
                                })
                                .catch(reject); // If any model fails to load, reject the main promise
                        })
                        .catch(reject); // Catch errors from the initial Supabase fetch
                });
            }

            // Function to fetch dialogue data for a character
            async function fetchDialogueData(characterId, motherLang, newLang) {
                try {
                    console.log("Fetching dialogue data for character:", characterId);
                    
                    // Fetch scenario for the specific character
                    const { data: scenarios, error: scenarioError } = await supabase
                        .from('dialogue_scenarios')
                        .select('id')
                        .eq('character_id', characterId)
                        .eq('is_active', true);

                    if (scenarioError || !scenarios || scenarios.length === 0) {
                        console.error('Error fetching scenarios:', scenarioError);
                        throw new Error('No active dialogue scenario found for character');
                    }

                    const scenarioId = scenarios[0].id;
                    console.log("Found scenario:", scenarioId, "for character:", characterId);

                    // Fetch steps with translations
                    const { data: steps, error: stepsError } = await supabase
                        .from('dialogue_steps')
                        .select(`
                            id,
                            step_order,
                            is_user_speaking,
                            translations (
                                text,
                                phonetic_text,
                                phonetic_text_ru,
                                phonetic_text_ar,
                                phonetic_text_es,
                                phonetic_text_en,
                                phonetic_text_ar_recognition,
                                language:languages (
                                    code
                                )
                            )
                        `)
                        .eq('scenario_id', scenarioId)
                        .order('step_order');

                    if (stepsError) {
                        console.error('Error fetching steps:', stepsError);
                        throw stepsError;
                    }

                    // Clear existing dialogue data
                    dialogueSteps[newLang] = [];
                    dialogueSteps[motherLang] = [];
                    vendorResponses[newLang] = [];
                    vendorResponses[motherLang] = [];

                    // Process steps
                    steps.forEach(step => {
                        const newLangTranslation = step.translations.find(t => t.language.code === newLang);
                        const motherLangTranslation = step.translations.find(t => t.language.code === motherLang);

                        if (newLangTranslation && motherLangTranslation) {
                            if (step.is_user_speaking) {
                                dialogueSteps[newLang].push(newLangTranslation);
                                dialogueSteps[motherLang].push(motherLangTranslation);
                            } else {
                                vendorResponses[newLang].push(newLangTranslation);
                                vendorResponses[motherLang].push(motherLangTranslation);
                            }
                        }
                    });

                    console.log("Loaded dialogue data for character:", characterId, {
                        dialogueSteps: dialogueSteps[newLang].length,
                        vendorResponses: vendorResponses[newLang].length
                    });

                } catch (error) {
                    console.error("Error in fetchDialogueData:", error);
                    throw error;
                }
            }

            const clock = new THREE.Clock();
            const container = document.getElementById('container');

            const stats = new Stats();
            container.appendChild(stats.dom);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            const pmremGenerator = new THREE.PMREMGenerator(renderer);

            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xbfe3dd);
            scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;

            // Load player character model
            const playerLoader = new GLTFLoader();
            playerLoader.load('models/player.glb', (gltf) => {
                player = gltf.scene;
                player.position.set(2.5, -2, 0); // Move player farther from vendor // Adjusted starting position
                player.scale.set(0.5, 0.5, 0.5); // Adjust scale based on model size
                player.visible = false; // Hide the player model in first-person view
                scene.add(player);
                registerCollidableObject(player);

                // Adjust camera for first-person POV after loading
                camera.position.set(player.position.x, player.position.y + 1.6, player.position.z); // Eye level
                console.log("Player loaded:", player);
            }, undefined, (error) => {
                console.error('Error loading player model:', error);
            });

            // Add these variables at the top with other initialization variables
            let activeCharacter = null;
            let characters = {
                vendor: null,
                popCat: null
            };
            const DIALOGUE_DISTANCE = 2;
            const DIALOGUE_RESET_DISTANCE = 2;

            // Add this variable with other initialization variables
            let resetCooldown = false;

            // Add these variables at the top with other initialization variables
            let dialogueStartCooldown = false;
            let lastCharacterId = null;

            // Add boundary limits after other initialization variables
            const MAP_BOUNDARIES = {
                minX: -2.5,
                maxX: 2.9,
                minZ: -2.9,
                maxZ: 2.4
            };

            // Add collision detection variables after other initialization variables
            const COLLISION_DISTANCE = 1.0; // Distance to maintain from objects
            const sceneObjects = []; // Array to store all collidable objects

            // Add these variables at the top with other initialization variables
            let lastDistanceCheck = 0;
            const DISTANCE_CHECK_COOLDOWN = 500; // Check distance every 500ms instead of every frame

            // Add this function to register objects for collision detection
            function registerCollidableObject(object) {
                if (object) {
                    sceneObjects.push(object);
                    console.log("Registered object for collision:", object);
                }
            }

            // Camera setup for first-person POV
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            // Lock pointer for mouse look
            container.requestPointerLock = container.requestPointerLock || container.mozRequestPointerLock;
            document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock;

            container.addEventListener('click', () => {
                container.requestPointerLock();
            });

            // Keyboard controls
            const keys = { 
                forward: false,  // W or equivalent
                left: false,     // A or equivalent
                backward: false, // S or equivalent
                right: false     // D or equivalent
            };

            document.addEventListener('keydown', (event) => {
                switch (event.code) {
                    case 'KeyW':
                    case 'ArrowUp':
                        keys.forward = true;
                        break;
                    case 'KeyA':
                    case 'ArrowLeft':
                        keys.left = true;
                        break;
                    case 'KeyS':
                    case 'ArrowDown':
                        keys.backward = true;
                        break;
                    case 'KeyD':
                    case 'ArrowRight':
                        keys.right = true;
                        break;
                }
            });

            document.addEventListener('keyup', (event) => {
                switch (event.code) {
                    case 'KeyW':
                    case 'ArrowUp':
                        keys.forward = false;
                        break;
                    case 'KeyA':
                    case 'ArrowLeft':
                        keys.left = false;
                        break;
                    case 'KeyS':
                    case 'ArrowDown':
                        keys.backward = false;
                        break;
                    case 'KeyD':
                    case 'ArrowRight':
                        keys.right = false;
                        break;
                }
            });

            // Mobile Controls Setup
            const mobileControls = document.getElementById('mobile-controls');
            const upBtn = document.getElementById('up-btn');
            const downBtn = document.getElementById('down-btn');
            const leftBtn = document.getElementById('left-btn');
            const rightBtn = document.getElementById('right-btn');

            // Function to check if device is mobile/touch-enabled
            function isMobileDevice() {
                return (
                    'ontouchstart' in window ||
                    navigator.maxTouchPoints > 0 ||
                    navigator.msMaxTouchPoints > 0 ||
                    window.innerWidth <= 1024
                );
            }

            // Initialize mobile controls
            function initMobileControls() {
                if (isMobileDevice()) {
                    mobileControls.style.display = 'block';
                    
                    // Prevent default touch behaviors
                    document.addEventListener('touchmove', function(e) {
                        if (e.target.closest('#mobile-controls')) {
                            e.preventDefault();
                        }
                    }, { passive: false });

                    // Handle touch events for d-pad buttons
                    const buttons = {
                        'up-btn': 'forward',
                        'down-btn': 'backward',
                        'left-btn': 'left',
                        'right-btn': 'right'
                    };

                    Object.entries(buttons).forEach(([btnId, direction]) => {
                        const btn = document.getElementById(btnId);
                        if (btn) {
                            // Touch events
                            btn.addEventListener('touchstart', (e) => {
                                e.preventDefault();
                                keys[direction] = true;
                            }, { passive: false });

                            btn.addEventListener('touchend', (e) => {
                                e.preventDefault();
                                keys[direction] = false;
                            }, { passive: false });

                            // Mouse events (for testing on desktop)
                            btn.addEventListener('mousedown', () => {
                                keys[direction] = true;
                            });

                            btn.addEventListener('mouseup', () => {
                                keys[direction] = false;
                            });

                            btn.addEventListener('mouseleave', () => {
                                keys[direction] = false;
                            });
                        }
                    });
                }
            }

            // Call initMobileControls after window loads
            window.addEventListener('load', initMobileControls);

            // Reinitialize on orientation change
            window.addEventListener('orientationchange', initMobileControls);

            // Handle touch move for camera rotation
            let touchStartX = 0;
            let touchStartY = 0;

            document.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1 && !e.target.closest('#mobile-controls')) {
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                }
            });

            document.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1 && !e.target.closest('#mobile-controls')) {
                    const touch = e.touches[0];
                    const movementX = touch.clientX - touchStartX;
                    const movementY = touch.clientY - touchStartY;
                    
                    const sensitivity = 0.002;
                    yaw -= movementX * sensitivity;
                    pitch -= movementY * sensitivity;
                    pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
                    
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                    
                    updateCamera();
                }
            });

            const velocity = new THREE.Vector3();
            const speed = 5.0;
            let yaw = 0; // Horizontal rotation (y-axis)
            let pitch = 0; // Vertical rotation (x-axis);

            // Add this function near the top, after camera initialization but before any event listeners
            function updateCamera() {
                if (!camera) return;  // Add safety check
                camera.rotation.order = 'YXZ';
                camera.rotation.y = yaw;
                camera.rotation.x = pitch;
            }

            // Update the mousemove event listener to include error handling
            document.addEventListener('mousemove', (event) => {
                try {
                if (document.pointerLockElement === container) {
                    const sensitivity = 0.002;
                    yaw -= event.movementX * sensitivity;
                    pitch -= event.movementY * sensitivity;
                    pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch)); // Limit pitch to avoid flipping
                    updateCamera();
                    }
                } catch (error) {
                    console.error('Error in mousemove handler:', error);
                }
            });

            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('jsm/libs/draco/gltf/');

            const loader = new GLTFLoader();
            loader.setDRACOLoader(dracoLoader);

            // Load the existing Littlest Tokyo model
            loader.load('models/gltf/LittlestTokyo.glb', function (gltf) {
                const model = gltf.scene;
                model.position.set(1, 1, 0);
                model.scale.set(0.01, 0.01, 0.01);
                scene.add(model);
                registerCollidableObject(model);

                mixer = new THREE.AnimationMixer(model);
                mixer.clipAction(gltf.animations[0]).play();
            }, undefined, function (e) {
                console.error(e);
            });

            function createDialogueBox(dialogueData, isUserSpeaking = false) {
                try {
                    // Check if dialogueData exists and is a string
                    if (!dialogueData || typeof dialogueData !== 'string') {
                        console.error('Invalid dialogueData provided:', dialogueData);
                        return null;
                    }

                    // Create container with initial position at bottom
                const container = document.createElement('div');
                    container.className = 'dialogue-container position-1';
                
                // Create replay button
                const replayButton = document.createElement('button');
                replayButton.className = 'replay-button';
                    replayButton.onclick = (event) => {
                        event.stopPropagation();
                        const dialogueBox = replayButton.nextElementSibling;
                        const isVendorBox = dialogueBox.classList.contains('vendor');
                        
                        // Calculate step from bottom up
                        const totalBoxes = dialogueBoxesElement.children.length;
                        const boxIndex = Array.from(dialogueBoxesElement.children).indexOf(replayButton.parentElement);
                        const stepsFromBottom = totalBoxes - boxIndex - 1;
                        
                        console.log('Replay clicked:', { 
                            boxIndex,
                            totalBoxes,
                            stepsFromBottom,
                            isVendorBox,
                            dialogueBoxText: dialogueBox.textContent
                        });
                        
                        handleReplayClick(boxIndex, isVendorBox);
                    };

                    // Create the dialogue box
                    const box = document.createElement('div');
                    box.className = `dialogue-box ${isUserSpeaking ? 'user' : 'vendor'}`;
                    box.dataset.isVendor = !isUserSpeaking;

                    // Split the dialogue data into parts (text, phonetic, translation)
                    const parts = dialogueData.split('|');
                    if (parts.length >= 1) {
                        const mainText = document.createElement('span');
                        mainText.className = 'highlighted';
                        
                        // Split the text into words and create spans
                        const words = parts[0].split(' ');
                    words.forEach((word, index) => {
                        const span = document.createElement('span');
                        span.className = 'word';
                            // Add lang attribute if the text contains Arabic characters
                            if (/[\u0600-\u06FF]/.test(word)) {
                                span.setAttribute('lang', 'ar');
                            }
                            span.style.color = '#000000';
                            span.textContent = word;
                            mainText.appendChild(span);
                            
                            if (index < words.length - 1) {
                                mainText.appendChild(document.createTextNode(' '));
                            }
                        });
                        
                        box.appendChild(mainText);

                        if (parts.length >= 2) {
                            const phoneticText = document.createElement('span');
                            phoneticText.className = `instruction${isUserSpeaking ? ' instruction-flash' : ''}`;
                            // Add lang attribute if the phonetic text contains Arabic characters
                            if (/[\u0600-\u06FF]/.test(parts[1])) {
                                phoneticText.setAttribute('lang', 'ar');
                            }
                            phoneticText.textContent = ` (${parts[1]}) `;
                            box.appendChild(phoneticText);
                        }

                        if (parts.length >= 3) {
                            const translationText = document.createElement('span');
                            translationText.className = 'translation';
                            // Add lang attribute if the translation contains Arabic characters
                            if (/[\u0600-\u06FF]/.test(parts[2])) {
                                translationText.setAttribute('lang', 'ar');
                            }
                            translationText.textContent = parts[2];
                            box.appendChild(translationText);
                        }
                    }

                    // Add elements to container
                container.appendChild(replayButton);
                    container.appendChild(box);

                    // Add speaker button for both user and vendor dialogue boxes
                    const speakerButton = document.createElement('button');
                    speakerButton.className = 'speaker-button';
                    speakerButton.onclick = (event) => {
                        event.stopPropagation();
                        const dialogueBox = event.target.previousElementSibling;
                        const text = dialogueBox.querySelector('.highlighted').textContent;
                        speakVendorResponse(text); // Reuse the vendor's speech function
                    };
                    container.appendChild(speakerButton);

                    return container;
                } catch (error) {
                    console.error('Error in createDialogueBox:', error);
                    return null;
                }
            }

            function updateBoxPositions() {
                const boxes = Array.from(dialogueBoxes);
                boxes.forEach((container, index) => {
                    // Remove any existing position class
                    container.className = 'dialogue-container';
                    
                    // Add new position class after a brief delay to ensure smooth animation
                    setTimeout(() => {
                        const position = boxes.length - index;
                    container.classList.add(`position-${position}`);
                    }, 10);
                });
            }

            function highlightWords(spokenText) {
                try {
                const currentDialogue = dialogueSteps[languageConfig.newLanguage][currentStep];
                    if (!currentDialogue) {
                        console.error('No dialogue found for current step:', currentStep);
                        return false;
                    }
                    
                    // Function to clean text for comparison
                    const cleanTextForComparison = (text) => {
                        return text
                            .replace(/[.,!?¬ø¬°ÿåÿü'"]/g, '')  // Remove all punctuation including quotes
                    .replace(/\s+/g, ' ')        // Normalize spaces
                    .trim()
                            .toLowerCase();
                    };
                    
                    // Get the text to compare against based on language
                    let textToCompare;
                    if (languageConfig.newLanguage === 'ar') {
                        textToCompare = currentDialogue.phonetic_text_ar_recognition || currentDialogue.text;
                    } else {
                        textToCompare = currentDialogue.text;
                    }
                    
                    // Clean texts for comparison
                    const cleanedExpectedText = cleanTextForComparison(textToCompare);
                    const cleanedSpokenText = cleanTextForComparison(spokenText);
                    
                    console.log('Comparing texts:', {
                        expected: cleanedExpectedText,
                        spoken: cleanedSpokenText,
                        originalText: currentDialogue.text
                    });

                    // Get the current dialogue box
                    const currentBox = dialogueBoxes[dialogueBoxes.length - 1];
                    if (!currentBox) {
                        console.error('No current dialogue box found');
                        return false;
                    }

                    const mainText = currentBox.querySelector('.dialogue-box .highlighted');
                    if (!mainText) {
                        console.error('No highlighted text element found');
                        return false;
                    }

                    // Get all word spans
                    const wordSpans = mainText.querySelectorAll('.word');
                    if (!wordSpans.length) {
                        console.error('No word spans found');
                        return false;
                    }

                    // Split both texts into words
                    const expectedWords = cleanedExpectedText.split(' ');
                    const spokenWords = cleanedSpokenText.split(' ');
                    
                    let totalChars = 0;
                    let matchedChars = 0;

                    // Process each expected word
                    expectedWords.forEach((expectedWord, index) => {
                        const cleanedExpectedWord = cleanTextForComparison(expectedWord);
                        const wordSpan = wordSpans[index];
                        
                        if (!wordSpan) return;
                        
                        totalChars += cleanedExpectedWord.length;
                        
                        // Find best match among spoken words
                        let bestMatchScore = 0;
                        spokenWords.forEach(spokenWord => {
                            const cleanedSpokenWord = cleanTextForComparison(spokenWord);
                            const score = calculateMatchScore(cleanedExpectedWord, cleanedSpokenWord);
                            bestMatchScore = Math.max(bestMatchScore, score);
                        });

                        // Update word color based on match score
                        if (bestMatchScore > 0.7) {
                            wordSpan.style.color = '#0066cc';
                            matchedChars += cleanedExpectedWord.length;
                        } else {
                            wordSpan.style.color = '#000000';
                        }
                    });

                    // Calculate overall match percentage
                    const matchPercentage = (matchedChars / totalChars) * 100;
                    console.log('Match percentage:', matchPercentage);
                    
                    // Return true if overall match is >= 70%
                    const isMatch = matchPercentage >= 70;
                    if (isMatch) {
                        console.log('Match successful, proceeding with dialogue');
                    }
                    return isMatch;
                } catch (error) {
                    console.error('Error in highlightWords:', error);
                    return false;
                }
            }

            // Helper function to calculate match score between two words
            function calculateMatchScore(word1, word2) {
                const maxLength = Math.max(word1.length, word2.length);
                let matchCount = 0;
                const minLength = Math.min(word1.length, word2.length);
                
                for (let i = 0; i < minLength; i++) {
                    if (word1[i] === word2[i]) {
                        matchCount++;
                    }
                }
                
                return matchCount / maxLength;
            }

            // Update the updatePlayer function to include cooldown for distance checks
            function updatePlayer(delta) {
                // console.log("[Mobile Debug] updatePlayer running"); // Optional: uncomment if needed, can be spammy
                if (!player) return;
                if (isNaN(delta) || delta <= 0) return;

                velocity.set(0, 0, 0);

                const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
                const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);

                // Calculate new position
                const newPosition = player.position.clone();
                if (keys.forward) newPosition.add(forward.multiplyScalar(speed * delta));
                if (keys.backward) newPosition.add(forward.multiplyScalar(-speed * delta));
                if (keys.left) newPosition.add(right.multiplyScalar(-speed * delta));
                if (keys.right) newPosition.add(right.multiplyScalar(speed * delta));

                // Check map boundaries
                if (newPosition.x < MAP_BOUNDARIES.minX) newPosition.x = MAP_BOUNDARIES.minX;
                if (newPosition.x > MAP_BOUNDARIES.maxX) newPosition.x = MAP_BOUNDARIES.maxX;
                if (newPosition.z < MAP_BOUNDARIES.minZ) newPosition.z = MAP_BOUNDARIES.minZ;
                if (newPosition.z > MAP_BOUNDARIES.maxZ) newPosition.z = MAP_BOUNDARIES.maxZ;

                // Update position
                player.position.copy(newPosition);
                camera.position.set(player.position.x, player.position.y + 1.6, player.position.z);

                // Only check distances if cooldown has passed
                const currentTime = Date.now();
                if (currentTime - lastDistanceCheck >= DISTANCE_CHECK_COOLDOWN) {
                    console.log("[Mobile Debug] Passed distance check cooldown");
                    lastDistanceCheck = currentTime;

                    // Check distances to all characters
                    let closestCharacter = null;
                    let closestDistance = Infinity;
                    console.log("[Mobile Debug] Checking distances to characters:", Object.keys(characters));

                    Object.values(characters).forEach(character => {
                        if (!character) {
                            console.log("[Mobile Debug] Skipping null character");
                            return; 
                        }
                        const distance = calculateDistance(player.position, character.position);
                        console.log(`[Mobile Debug] Distance to ${character.characterId}: ${distance}`); 
                        if (distance < DIALOGUE_DISTANCE && distance < closestDistance) {
                            console.log(`[Mobile Debug] New closest character found: ${character.characterId} at distance ${distance}`);
                            closestCharacter = character;
                            closestDistance = distance;
                        }
                    });

                    // If player moves too far from active character, reset dialogue
                    if (activeCharacter && calculateDistance(player.position, activeCharacter.position) > DIALOGUE_RESET_DISTANCE) {
                        console.log("[Mobile Debug] Player moved too far, resetting dialogue");
                        if (hasStartedDialogue && !resetCooldown) {
                            resetDialogue();
                        }
                    }
                    // If player is close to a character and dialogue hasn't started
                    else if (closestCharacter && !hasStartedDialogue && !resetCooldown) {
                        console.log(`[Mobile Debug] Conditions met! Attempting to start dialogue with ${closestCharacter.characterId}`);
                        startDialogueWithCharacter(closestCharacter); 
                    } else {
                        // Log why dialogue isn't starting
                        if (!closestCharacter) console.log("[Mobile Debug] Dialogue not starting: No character close enough.");
                        if (hasStartedDialogue) console.log("[Mobile Debug] Dialogue not starting: Dialogue already active.");
                        if (resetCooldown) console.log("[Mobile Debug] Dialogue not starting: In reset cooldown.");
                    }
                } 
                // else { console.log("[Mobile Debug] Still in distance check cooldown"); } // Optional: uncomment if needed
            }

            // Update the startDialogueWithCharacter function to properly handle vendor
            async function startDialogueWithCharacter(character) {
                // --- Temporary Simple Test for Mobile Debugging --- 
                try {
                    console.log("[Mobile Test] Attempting simple dialogue for:", character.characterId);
            
                    const dialogueContainer = document.createElement('div');
                    dialogueContainer.className = 'dialogue-container'; // Start without position class initially
            
                    const dialogueBox = document.createElement('div');
                    dialogueBox.className = 'dialogue-box';
                    dialogueBox.textContent = `TEST: Dialogue with ${character.characterId}`;
                    dialogueBox.style.backgroundColor = 'lightgreen'; // Make it obvious
            
                    dialogueContainer.appendChild(dialogueBox);
                    dialogueBoxesElement.appendChild(dialogueContainer);
            
                    // Add to our array for management
                    dialogueBoxes.push(dialogueContainer);
                    if (dialogueBoxes.length > 10) {
                        const oldestBox = dialogueBoxes.shift();
                        oldestBox.remove();
                    }
            
                    // Apply positioning after adding to DOM
                    updateBoxPositions(); 
            
                    console.log("[Mobile Test] Simple box added to DOM. Count:", dialogueBoxes.length);
            
                    // --- Minimal state updates needed for testing ---
                    hasStartedDialogue = true; // Prevent immediate re-triggering
                    activeCharacter = character;
                    lastCharacterId = character.characterId;
                    dialogueStartCooldown = true; // Apply cooldown
                    setTimeout(() => { dialogueStartCooldown = false; }, 2000);
            
                } catch (e) {
                    console.error("[Mobile Test] Error creating simple test box:", e);
                    dialogueStartCooldown = false; // Reset cooldown on error
                }
                // --- End of Temporary Simple Test ---

                /* --- Original Logic Start (Commented Out for Mobile Test) ---
                try {
                    // Check if we're already in dialogue with this character
                    if (character.characterId === lastCharacterId && hasStartedDialogue) {
                        return;
                    }

                    // Check if we're in cooldown
                    if (dialogueStartCooldown) {
                        return;
                    }

                    dialogueStartCooldown = true;
                    activeCharacter = character;
                    lastCharacterId = character.characterId;
                    console.log("Starting dialogue with character:", character.characterId);
                    
                    await fetchDialogueData(character.characterId, languageConfig.motherLanguage, languageConfig.newLanguage);
                    
                    currentStep = 0;
                    dialogueBoxes = [];
                    
                    updateDialogue(0, true);
                    hasStartedDialogue = true;
                    
                    if (recognition) {
                        setTimeout(() => {
                            initializeRecognition();
                            try {
                                recognition.start();
                                isRecognizing = true;
                            } catch (e) {
                                console.error("Failed to start recognition:", e);
                            }
                        }, 500);
                    }

                    // Reset cooldown after 2 seconds
                    setTimeout(() => {
                        dialogueStartCooldown = false;
                    }, 2000);
                } catch (error) {
                    console.error("Error starting dialogue:", error);
                    dialogueStartCooldown = false;
                }
                --- Original Logic End --- */
            }

            // Add helper function to reset dialogue
            function resetDialogue() {
                resetCooldown = true;
                lastCharacterId = null;  // Reset the last character ID
                
                if (recognition) {
                    recognition.abort();
                    isRecognizing = false;
                }
                if (speechSynthesis.speaking) {
                    speechSynthesis.cancel();
                }
                
                dialogueBoxes.forEach((box) => {
                    box.style.opacity = '0';
                    box.style.transform = 'translateY(20px)';
                    setTimeout(() => box.remove(), 300);
                });
                
                dialogueBoxes = [];
                hasStartedDialogue = false;
                currentStep = 0;
                activeCharacter = null;
                
                setTimeout(() => {
                    resetCooldown = false;
                }, 2000);
            }

            // Add this function to update flashing state
            function updateFlashingState() {
                // Remove flashing from all phonetic texts
                document.querySelectorAll('.instruction-flash').forEach(el => {
                    el.classList.remove('instruction-flash');
                });
                
                // Add flashing only to the latest user dialogue box
                const latestBox = dialogueBoxes[dialogueBoxes.length - 1];
                if (latestBox && latestBox.querySelector('.dialogue-box.user')) {
                    const phoneticText = latestBox.querySelector('.instruction');
                    if (phoneticText) {
                        phoneticText.classList.add('instruction-flash');
                    }
                }
            }

            // Modify updateDialogue to call updateFlashingState
            function updateDialogue(step, isUserSpeaking) {
                try {
                    // Format dialogue data with proper separators
                    const dialogueArray = isUserSpeaking ? dialogueSteps : vendorResponses;
                    const newLangData = dialogueArray[languageConfig.newLanguage]?.[step];
                    const motherLangData = dialogueArray[languageConfig.motherLanguage]?.[step];
                    
                    if (!newLangData || !motherLangData) {
                        console.error('Missing dialogue data for step:', step);
                        return;
                    }

                    // Reset colors of words in the previous dialogue box to black
                    const previousBox = dialogueBoxes[dialogueBoxes.length - 1]?.querySelector('.dialogue-box');
                    if (previousBox) {
                        const wordSpans = previousBox.querySelectorAll('.word');
                        wordSpans.forEach(span => {
                            span.style.color = '#000000';
                        });
                    }

                    // Get the appropriate phonetic text based on mother language
                    let phoneticText;
                    switch (languageConfig.motherLanguage) {
                        case 'ru':
                            phoneticText = newLangData.phonetic_text_ru || newLangData.phonetic_text;
                            break;
                        case 'ar':
                            phoneticText = newLangData.phonetic_text_ar || newLangData.phonetic_text;
                            break;
                        case 'es':
                            phoneticText = newLangData.phonetic_text_es || newLangData.phonetic_text;
                            break;
                        case 'en':
                            phoneticText = newLangData.phonetic_text_en || newLangData.phonetic_text;
                            break;
                        default:
                            phoneticText = newLangData.phonetic_text;
                    }

                    const dialogueData = `${newLangData.text}|${phoneticText}|${motherLangData.text}`;
                    const dialogueBox = createDialogueBox(dialogueData, isUserSpeaking);
                    
                    if (dialogueBox) {
                        dialogueBoxesElement.appendChild(dialogueBox);
                        dialogueBoxes.push(dialogueBox);
                        updateBoxPositions();
                        updateFlashingState();
                        
                        // Animate Pop Cat if it's the active character
                        if (activeCharacter === characters.popCat) {
                            animatePopCat();
                        }
                        
                        if (dialogueBoxes.length > 10) {
                            const oldestBox = dialogueBoxes.shift();
                            oldestBox.remove();
                        }
                    }
                } catch (error) {
                    console.error('Error in updateDialogue:', error);
                }
            }

            // Calculate distance
            function calculateDistance(pos1, pos2) {
                if (!pos1 || !pos2) {
                    console.warn("Position undefined:", { pos1, pos2 });
                    return Infinity;
                }
                const dx = pos2.x - pos1.x;
                const dy = pos2.y - pos1.y;
                const dz = pos2.z - pos1.z;
                return Math.sqrt(dx * dx + dy * dy + dz * dz);
            }

            // Handle vendor interaction (not used directly now, but kept for consistency)
            function handleVendorInteraction() {
                if (dialogueBoxes.length === 0 || dialogueBoxes[dialogueBoxes.length - 1].textContent !== `-${vendorResponses[vendorResponses.length - 1].en}`) {
                    const box = createDialogueBox(`${vendorResponses[vendorResponses.length - 1].en} (${vendorResponses[vendorResponses.length - 1].phoneticRu}) ${vendorResponses[vendorResponses.length - 1].translation}`);
                    dialogueBoxes.push(box);
                    updateBoxPositions();
                }
            }

            // Continuous Speech Recognition Setup
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            let recognition;
            let isRecognizing = false;
            let startTime = 0;

            if (!SpeechRecognition) {
                console.error("Speech recognition is not supported in this browser.");
                createDialogueBox("Speech recognition is not supported in this browser. Please try using Chrome, Edge, or Safari.");
            } else {
                try {
                    recognition = new SpeechRecognition();
                    recognition.interimResults = false;
                    recognition.maxAlternatives = 1;
                    recognition.continuous = false;

                    recognition.onstart = () => {
                        console.log("Speech recognition started");
                        isRecognizing = true;
                    };

                    recognition.onspeechstart = () => {
                        console.log("Speech detected");
                    };

                    recognition.onerror = (event) => {
                        console.error("Speech recognition error:", event.error);
                        isRecognizing = false;
                        
                        if (event.error === 'not-allowed') {
                            createDialogueBox("Error: Microphone access not granted. Please allow microphone access and reload the page.");
                        } else if (event.error === 'no-speech') {
                            console.log("No speech detected");
                            // Only restart if we're in an active dialogue
                            if (hasStartedDialogue && !speechSynthesis.speaking) {
                                setTimeout(startRecognition, 1000);
                            }
                        } else if (event.error === 'network') {
                            createDialogueBox("Network error occurred. Please check your internet connection.");
                        } else if (event.error === 'aborted') {
                            console.log("Recognition aborted");
                        } else {
                            createDialogueBox(`Speech recognition error: ${event.error}`);
                        }
                    };

                    recognition.onend = () => {
                        console.log("Speech recognition ended");
                        isRecognizing = false;
                        // Only restart if we're in an active dialogue and not speaking
                        if (hasStartedDialogue && !speechSynthesis.speaking) {
                            setTimeout(() => {
                                if (!isRecognizing) {  // Double check it's still not recognizing
                                    startRecognition();
                                }
                            }, 100);
                        }
                    };

                    recognition.onresult = (event) => {
                        try {
                            if (!event.results || event.results.length === 0) {
                                console.error('No results in recognition event');
                                return;
                            }

                            const currentTime = Date.now();
                            if (currentTime - lastRecognitionTime < 500) {
                                console.log('Skipping recognition - too soon after last recognition');
                                return;
                            }
                            lastRecognitionTime = currentTime;

                            const result = event.results[event.results.length - 1];
                            if (!result || !result[0]) {
                                console.error('Invalid recognition result structure');
                                return;
                            }

                            const spokenText = result[0].transcript.trim();
                            console.log("Spoken text recognized:", spokenText);
                            
                            if (currentStep >= dialogueSteps[languageConfig.newLanguage].length) {
                                console.error('Current step is out of bounds:', currentStep);
                                return;
                            }

                            if (highlightWords(spokenText)) {
                                if (recognition && isRecognizing) {
                                    recognition.stop();
                                    isRecognizing = false;
                                }

                                setTimeout(() => {
                                    updateDialogue(currentStep, false);
                                    const vendorResponse = vendorResponses[languageConfig.newLanguage][currentStep];
                                    if (vendorResponse) {
                                        speakVendorResponse(vendorResponse.text);
                                        const vendorDelay = calculateVendorDelay(vendorResponse.text);
                                        
                                        setTimeout(() => {
                                            currentStep++;
                                            if (currentStep < dialogueSteps[languageConfig.newLanguage].length) {
                                                updateDialogue(currentStep, true);
                                                setTimeout(() => {
                                                    startRecognition();
                                                }, 500);
                                            }
                                        }, vendorDelay);
                                    }
                                }, 500);
                            } else {
                                console.log("Recognition did not meet threshold - continue listening");
                            }
                        } catch (error) {
                            console.error('Error in recognition result handler:', error);
                            if (recognition && !isRecognizing) {
                                setTimeout(() => {
                                    try {
                                        recognition.start();
                                        isRecognizing = true;
                                    } catch (e) {
                                        console.error('Failed to recover recognition:', e);
                                    }
                                }, 1000);
                            }
                        }
                    };
                } catch (error) {
                    console.error("Error initializing recognition:", error);
                }
            }

            // Initialize everything when the page loads
            window.addEventListener('load', async () => {
                try {
                    await initVendorVoice();
                    await fetchLanguages(); // Fetch languages first
                    
                    // Load models concurrently
                    await Promise.all([
                        loadPopCat(),
                        fetchCharacters() 
                    ]);
                    
                    console.log("All models and languages loaded, setting up start button.");

                    document.getElementById('start-game').addEventListener('click', async () => {
                        languageConfig.motherLanguage = document.getElementById('mother-language').value;
                        languageConfig.newLanguage = document.getElementById('new-language').value;
                        
                        if (languageConfig.motherLanguage === languageConfig.newLanguage) {
                            alert('Please select different languages for learning');
                            return;
                        }
                        
                        document.getElementById('language-selection').style.display = 'none';
                        setupVoice(); // Setup voice after languages are confirmed
                        await initGame();
                    });
                } catch (error) {
                    console.error('Error during initial loading:', error);
                    // Optionally display an error message to the user
                }
            });

            // Remove the old event listener
            document.getElementById('start-game').removeEventListener('click', () => {});

            // Make initGame async
            async function initGame() {
                if (!recognition) {
                    console.error("Speech recognition not initialized");
                    createDialogueBox("Speech recognition is not available. Please use a supported browser like Chrome, Edge, or Safari.");
                    return;
                }
                
                // Check for HTTPS
                if (window.location.protocol !== 'https:') {
                    console.error("Site must be served over HTTPS for speech recognition to work");
                    createDialogueBox("This site requires HTTPS for speech recognition to work. Please use a secure connection.");
                    return;
                }
                
                try {
                    // Reset state
                    currentStep = 0;
                    isRecognizing = false;
                    hasStartedDialogue = false;
                    dialogueBoxes.forEach(box => box.remove());
                    dialogueBoxes = [];

                    // Wait for vendor to be loaded
                    if (!vendor) {
                        console.error("Vendor not loaded yet");
                        return;
                    }

                    // Get vendor's character ID
                    const vendorId = vendor.characterId;
                    console.log("Initializing game with vendor ID:", vendorId);

                    if (!vendorId) {
                        throw new Error("Vendor character ID is undefined");
                    }

                    // Fetch dialogue data for the vendor
                    await fetchDialogueData(vendorId, languageConfig.motherLanguage, languageConfig.newLanguage);

                    // Verify that dialogue data was loaded successfully
                    if (!dialogueSteps[languageConfig.newLanguage] || !dialogueSteps[languageConfig.newLanguage].length ||
                        !dialogueSteps[languageConfig.motherLanguage] || !dialogueSteps[languageConfig.motherLanguage].length) {
                        throw new Error("Failed to load dialogue data");
                    }
                
                    // Set up speech recognition for the new language
                    recognition.lang = languageConfig.newLanguage === 'en' ? 'en-US' : 
                                     languageConfig.newLanguage === 'es' ? 'es-ES' : 
                                     languageConfig.newLanguage === 'ru' ? 'ru-RU' :
                                     languageConfig.newLanguage === 'ar' ? 'ar-SA' : 'en-US';
                
                    try {
                        // Request microphone permission
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        console.log("Microphone access granted, stream active:", stream.active);
                        
                        // Start recognition only if we have microphone access
                        if (stream.active) {
                            isRecognizing = true;
                            recognition.start();
                        } else {
                            throw new Error("Microphone stream is not active");
                        }
                    } catch (permissionError) {
                        console.error("Microphone permission error:", permissionError);
                        createDialogueBox("Please allow microphone access to use speech recognition. Click the microphone icon in your browser's address bar and reload the page.");
                        return;
                    }
                } catch (err) {
                    console.error("Error initializing game:", err);
                    createDialogueBox(`Error: ${err.message}`);
                }
            }

            window.onresize = function () {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            };

            function animate() {
                try {
                    const delta = clock.getDelta();
                    if (mixer) mixer.update(delta);
                    if (popCatMixer) popCatMixer.update(delta);
                    updatePlayer(delta);
                    updateCamera();
                    stats.update();
                    renderer.render(scene, camera);
                } catch (error) {
                    console.error("Animation loop error:", error);
                }
            }

            renderer.setAnimationLoop(animate);

            // Speech synthesis setup
            const speechSynthesis = window.speechSynthesis;
            let vendorVoice = null;

            // Initialize vendor voice
            function initVendorVoice() {
                return new Promise((resolve) => {
                    if (speechSynthesis.getVoices().length > 0) {
                        setupVoice();
                        resolve();
                    } else {
                        speechSynthesis.onvoiceschanged = () => {
                            setupVoice();
                            resolve();
                        };
                    }
                });
            }

            function setupVoice() {
                const voices = speechSynthesis.getVoices();
                // Select voice based on NewLanguage
                switch (languageConfig.newLanguage) {
                    case 'ru':
                        vendorVoice = voices.find(voice => voice.lang.startsWith('ru-')) || 
                                    voices.find(voice => voice.lang.startsWith('en-')) || 
                                    voices[0];
                        break;
                    case 'es':
                        vendorVoice = voices.find(voice => voice.lang.startsWith('es-')) || 
                                    voices.find(voice => voice.lang.startsWith('en-')) || 
                                    voices[0];
                        break;
                    case 'ar':
                        vendorVoice = voices.find(voice => voice.lang.startsWith('ar-')) || 
                                    voices.find(voice => voice.lang.startsWith('en-')) || 
                                    voices[0];
                        break;
                    default:
                        vendorVoice = voices.find(voice => voice.lang.startsWith('en-')) || 
                                    voices[0];
                }
                console.log("Selected voice:", vendorVoice.name, vendorVoice.lang);
            }

            function speakVendorResponse(text) {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.voice = vendorVoice;
                utterance.rate = 0.9; // Slightly slower for clarity
                utterance.pitch = 1;
                
                // Set the language based on NewLanguage
                switch (languageConfig.newLanguage) {
                    case 'ru':
                        utterance.lang = 'ru-RU';
                        break;
                    case 'es':
                        utterance.lang = 'es-ES';
                        break;
                    case 'ar':
                        utterance.lang = 'ar-SA';
                        break;
                    default:
                        utterance.lang = 'en-US';
                }
                
                speechSynthesis.speak(utterance);
            }

            // Update the startRecognition function
            function startRecognition() {
                if (!recognition) {
                    console.error('Speech recognition not initialized');
                    return;
                }
                
                // If already recognizing, don't try to start again
                if (isRecognizing) {
                    console.log('Recognition already in progress');
                    return;
                }
                
                try {
                    // Stop any ongoing recognition first
                    recognition.stop();
                    isRecognizing = false;
                    
                    // Add a small delay before starting new recognition
                    setTimeout(() => {
                        try {
                            recognition.start();
                            isRecognizing = true;
                            console.log('Recognition started successfully');
                        } catch (e) {
                            console.error('Failed to start recognition:', e);
                            isRecognizing = false;
                            // Only retry if we're in an active dialogue
                            if (hasStartedDialogue && !speechSynthesis.speaking) {
                                setTimeout(startRecognition, 1000);
                            }
                        }
                    }, 100);
                } catch (e) {
                    console.error('Error in startRecognition:', e);
                    isRecognizing = false;
                    // Only retry if we're in an active dialogue
                    if (hasStartedDialogue && !speechSynthesis.speaking) {
                        setTimeout(startRecognition, 1000);
                    }
                }
            }

            // Update the handleReplayClick function
            function handleReplayClick(boxIndex, isVendorBox) {
                console.log('Handling replay:', { boxIndex, isVendorBox });
                
                // Stop current recognition and speech
                if (recognition && isRecognizing) {
                    recognition.abort();
                    isRecognizing = false;
                }
                if (speechSynthesis.speaking) {
                    speechSynthesis.cancel();
                }
                
                // Remove boxes with animation
                const boxesToRemove = dialogueBoxes.slice(boxIndex + 1);
                boxesToRemove.forEach((box, index) => {
                    box.style.opacity = '0';
                    box.style.transform = 'translateY(20px)';
                    box.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';
                    
                    setTimeout(() => {
                        box.remove();
                        dialogueBoxes.pop();
                    }, 300);
                });

                setTimeout(() => {
                    updateBoxPositions();
                }, 350);

                const stepNumber = Math.floor(boxIndex / 2);
                
                if (isVendorBox) {
                    const vendorResponse = vendorResponses[languageConfig.newLanguage][stepNumber];
                    if (vendorResponse) {
                        speakVendorResponse(vendorResponse.text);
                        
                        // Animate Pop Cat if it's the active character
                        if (activeCharacter === characters.popCat) {
                            animatePopCat();
                        }
                        
                        const vendorDelay = calculateVendorDelay(vendorResponse.text);
                        
                        setTimeout(() => {
                            currentStep = stepNumber + 1;
                            if (currentStep < dialogueSteps[languageConfig.newLanguage].length) {
                                updateDialogue(currentStep, true);
                                setTimeout(() => {
                                    if (!isRecognizing) {
                                        startRecognition();
                                    }
                                }, 500);
                            }
                        }, vendorDelay);
                    }
                } else {
                    currentStep = stepNumber;
                    // Animate Pop Cat if it's the active character
                    if (activeCharacter === characters.popCat) {
                        animatePopCat();
                    }
                    setTimeout(() => {
                        if (!isRecognizing) {
                            startRecognition();
                        }
                    }, 500);
                }
            }

            // Helper function to calculate delay based on text length
            function calculateVendorDelay(text) {
                // Base delay of 500ms
                const baseDelay = 500;
                // Add 100ms per character
                const charDelay = text.length * 100;
                // Cap maximum delay at 5000ms (5 seconds)
                return Math.min(baseDelay + charDelay, 5000);
            }

            // Add this function after the existing language-related functions
            function updateLanguageOptions(selectElement) {
                const motherLanguageSelect = document.getElementById('mother-language');
                const newLanguageSelect = document.getElementById('new-language');
                const selectedLanguage = selectElement.value;
                
                // Get all options from both selects
                const motherOptions = Array.from(motherLanguageSelect.options);
                const newOptions = Array.from(newLanguageSelect.options);
                
                if (selectElement === motherLanguageSelect) {
                    // If mother language is changed, update new language options
                    newOptions.forEach(option => {
                        option.disabled = option.value === selectedLanguage;
                        if (option.disabled && option.selected) {
                            // If the new language was the same as mother language,
                            // select the first available language
                            const firstAvailable = newOptions.find(opt => !opt.disabled);
                            if (firstAvailable) {
                                newLanguageSelect.value = firstAvailable.value;
                            }
                        }
                    });
                } else {
                    // If new language is changed, update mother language options
                    motherOptions.forEach(option => {
                        option.disabled = option.value === selectedLanguage;
                        if (option.disabled && option.selected) {
                            // If the mother language was the same as new language,
                            // select the first available language
                            const firstAvailable = motherOptions.find(opt => !opt.disabled);
                            if (firstAvailable) {
                                motherLanguageSelect.value = firstAvailable.value;
                            }
                        }
                    });
                }
            }

            // Update the language select elements to use the new function
            document.getElementById('mother-language').addEventListener('change', function() {
                updateLanguageOptions(this);
                updateLanguage(this.value, 'mother');
            });

            document.getElementById('new-language').addEventListener('change', function() {
                updateLanguageOptions(this);
                updateLanguage(this.value, 'new');
            });

            // Initialize the language options when the page loads
            document.addEventListener('DOMContentLoaded', function() {
                const motherLanguageSelect = document.getElementById('mother-language');
                const newLanguageSelect = document.getElementById('new-language');
                
                // Set English as default mother language
                motherLanguageSelect.value = 'en';
                
                // Set random new language (excluding English)
                setRandomNewLanguage();
                
                // Initialize language options
                updateLanguageOptions(motherLanguageSelect);
                updateLanguageOptions(newLanguageSelect);
            });

            // Update the setRandomNewLanguage function to ensure it never selects English
            function setRandomNewLanguage() {
                const newLanguageSelect = document.getElementById('new-language');
                const options = Array.from(newLanguageSelect.options).filter(opt => opt.value !== 'en');
                const randomIndex = Math.floor(Math.random() * options.length);
                newLanguageSelect.value = options[randomIndex].value;
                updateLanguageOptions(newLanguageSelect);
            }

            // Add Pop Cat animation control
            let popCatMixer = null;
            let popCatAnimation = null;

            function animatePopCat() {
                if (popCatAnimation) {
                    popCatAnimation.reset();
                    popCatAnimation.play();
                }
            }

            // Add this function after the existing language-related functions
            function updateLanguage(langCode, type) {
                if (type === 'mother') {
                    languageConfig.motherLanguage = langCode;
                } else if (type === 'new') {
                    languageConfig.newLanguage = langCode;
                }
                console.log("Updated language config:", languageConfig);
            }
        </script>
    </body>
</html>